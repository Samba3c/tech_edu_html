<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>小畫家</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
    }
    canvas {
      border: 1px solid #000;
      margin-top: 20px;
    }
    #color-picker, #brush-size, #brush-shape {
      margin-top: 20px;
    }
    #clear-btn, #fill-btn, #undo-btn, #save-btn {
      margin-top: 10px;
      padding: 12px 25px;
      font-size: 18px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    #clear-btn:hover, #fill-btn:hover, #undo-btn:hover, #save-btn:hover {
      background-color: #45a049;
    }
    #tools {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      flex-wrap: nowrap;
    }
    .tool-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label, select, input {
      font-size: 18px;
      margin-right: 10px;
    }
    .color-palette {
      display: flex;
      justify-content: center;
      margin-top: 20px;
    }
    .color-box {
      width: 40px;
      height: 40px;
      margin: 5px;
      cursor: pointer;
      border: 1px solid #000;
    }
    #color-display {
      width: 40px;
      height: 40px;
      border: 1px solid #000;
      margin-right: 10px;
    }
  </style>
</head>
<body>

  <h1>小畫家</h1>
  
  <!-- 工具栏 -->
  <div id="tools">
    <!-- 返回按钮 -->
    <div class="tool-group">
      <button id="undo-btn">返回</button>
    </div>

    <!-- 当前颜色、笔刷形状、画笔大小、油漆桶填色 -->
    <div class="tool-group">
      <div>
        <label for="color-display">當前顏色:</label>
        <div id="color-display"></div>
      </div>
      <div>
        <label for="brush-shape">筆刷形狀:</label>
        <select id="brush-shape">
          <option value="round">圓形</option>
          <option value="square">正方形</option>
        </select>
      </div>
      <div>
        <label for="brush-size">畫筆大小:</label>
        <input type="range" id="brush-size" min="1" max="10" value="5">
      </div>
      <button id="fill-btn">油漆桶填色</button>
    </div>
  </div>

  <div class="color-palette" id="color-palette">
    <!-- 顏色塊將會動態生成 -->
  </div>

  <canvas id="drawing-canvas" width="1024" height="768"></canvas>

  <div>
    <!-- 清除畫布和存檔按鈕 -->
    <button id="clear-btn">清除畫布</button>
    <button id="save-btn">存檔</button>
  </div>

  <script>
    const canvas = document.getElementById('drawing-canvas');
    const ctx = canvas.getContext('2d');
    const brushSize = document.getElementById('brush-size');
    const brushShape = document.getElementById('brush-shape');
    const clearBtn = document.getElementById('clear-btn');
    const fillBtn = document.getElementById('fill-btn');
    const undoBtn = document.getElementById('undo-btn');
    const saveBtn = document.getElementById('save-btn');
    const colorPalette = document.getElementById('color-palette');
    const colorDisplay = document.getElementById('color-display');

    let painting = false;
    let filling = false;
    let history = []; // 用來儲存畫布的歷史紀錄
    let currentHistoryIndex = -1; // 當前歷史紀錄索引
    let currentColor = "#000000"; // 默認顏色為黑色

    // 設定畫布背景
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // 定義顏色系列
    const baseColors = {
      "黑": "#000000", "白": "#ffffff", "紅": "#ff0000", "橙": "#ffa500", "黃": "#ffff00", "綠": "#008000", "藍": "#0000ff", "紫": "#800080"
    };

    // 顏色調整：降低亮度
    function adjustColorBrightness(hex, factor) {
      const rgb = hexToRgb(hex);
      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      hsl.l = Math.max(0, Math.min(1, hsl.l * factor)); // 降低亮度
      const adjustedRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
      return rgbToHex(adjustedRgb.r, adjustedRgb.g, adjustedRgb.b);
    }

    // 將十六進制顏色轉換為 RGB
    function hexToRgb(hex) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return { r, g, b };
    }

    // 將 RGB 顏色轉換為 HSL
    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0;
      let s = 0;
      let l = (max + min) / 2;
      const d = max - min;
      if (d !== 0) {
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        if (max === r) {
          h = (g - b) / d + (g < b ? 6 : 0);
        } else if (max === g) {
          h = (b - r) / d + 2;
        } else {
          h = (r - g) / d + 4;
        }
        h /= 6;
      }
      return { h, s, l };
    }

    // 將 HSL 顏色轉換為 RGB
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
    }

    // 將 RGB 顏色轉換為十六進制顏色
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    }

    // 動態生成顏色選擇塊
    function generateColorPalette() {
      const allColors = [];
      
      // 生成三個系列的顏色
      for (let colorName in baseColors) {
        const baseColor = baseColors[colorName];
        const secondColor = adjustColorBrightness(baseColor, 2 / 3);
        const thirdColor = adjustColorBrightness(baseColor, 1 / 3);

        allColors.push(baseColor, secondColor, thirdColor);
      }

      // 生成顏色塊
      allColors.forEach(color => {
        const colorBox = document.createElement('div');
        colorBox.classList.add('color-box');
        colorBox.style.backgroundColor = color;
        colorBox.addEventListener('click', () => {
          currentColor = color;
          ctx.strokeStyle = currentColor;
          ctx.fillStyle = currentColor;
          colorDisplay.style.backgroundColor = currentColor;
        });
        colorPalette.appendChild(colorBox);
      });
    }

    generateColorPalette();

    // 開始畫畫
    canvas.addEventListener('mousedown', (e) => {
      if (filling) {
        fillCanvas(e);
      } else {
        painting = true;
        draw(e);
      }
    });

    // 停止畫畫
    canvas.addEventListener('mouseup', () => {
      painting = false;
      ctx.beginPath();
      saveHistory(); // 保存當前狀態為歷史紀錄
    });

    // 畫畫中
    canvas.addEventListener('mousemove', draw);

    // 畫筆大小改變時更新
    brushSize.addEventListener('input', () => {
      ctx.lineWidth = brushSize.value;
    });

    // 畫筆形狀改變
    brushShape.addEventListener('change', () => {
      ctx.lineCap = brushShape.value;  // 畫筆圓形或正方形
      ctx.lineJoin = brushShape.value;
    });

    // 清除畫布
    clearBtn.addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      saveHistory(); // 清空後保存畫布狀態
    });

    // 油漆桶功能
    fillBtn.addEventListener('click', () => {
      filling = !filling;
      if (filling) {
        fillBtn.textContent = '停止油漆桶';
      } else {
        fillBtn.textContent = '油漆桶填色';
      }
    });

    // 返回上一個動作
    undoBtn.addEventListener('click', () => {
      if (currentHistoryIndex > 0) {
        currentHistoryIndex--;
        const previousState = history[currentHistoryIndex];
        ctx.putImageData(previousState, 0, 0);
      }
    });

    // 畫畫函數
    function draw(e) {
      if (!painting) return;

      ctx.strokeStyle = currentColor;
      ctx.lineWidth = brushSize.value;
      
      ctx.lineTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(e.clientX - canvas.offsetLeft, e.clientY - canvas.offsetTop);
    }

    // 填充顏色
    function fillCanvas(e) {
      const x = e.clientX - canvas.offsetLeft;
      const y = e.clientY - canvas.offsetTop;

      const targetColor = ctx.getImageData(x, y, 1, 1).data;
      if (targetColor[3] === 0) return; // 如果是透明區域，則不填充

      const fillColor = hexToRgb(currentColor);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;

      const stack = [[x, y]];

      while (stack.length > 0) {
        const [currentX, currentY] = stack.pop();
        const currentPixelIndex = (currentY * canvas.width + currentX) * 4;

        if (pixels[currentPixelIndex] === targetColor[0] &&
            pixels[currentPixelIndex + 1] === targetColor[1] &&
            pixels[currentPixelIndex + 2] === targetColor[2] &&
            pixels[currentPixelIndex + 3] === targetColor[3]) {

          pixels[currentPixelIndex] = fillColor.r;
          pixels[currentPixelIndex + 1] = fillColor.g;
          pixels[currentPixelIndex + 2] = fillColor.b;
          pixels[currentPixelIndex + 3] = 255;

          if (currentX > 0) stack.push([currentX - 1, currentY]);
          if (currentX < canvas.width - 1) stack.push([currentX + 1, currentY]);
          if (currentY > 0) stack.push([currentX, currentY - 1]);
          if (currentY < canvas.height - 1) stack.push([currentX, currentY + 1]);
        }
      }

      ctx.putImageData(imageData, 0, 0);
    }

    // 保存畫布的狀態到歷史紀錄
    function saveHistory() {
      const currentState = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (currentHistoryIndex < history.length - 1) {
        history = history.slice(0, currentHistoryIndex + 1); // 如果已經有後續紀錄，先切掉
      }
      history.push(currentState);
      currentHistoryIndex++;
    }

    // 存檔功能：將畫布保存為 PNG
    saveBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.href = canvas.toDataURL('image/png');
      link.download = 'my_drawing.png';
      link.click();
    });
  </script>

</body>
</html>
